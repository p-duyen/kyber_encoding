\documentclass{llncs}

\input{preamble.tex}
\input{notation.tex}

\begin{document} 

\title{Analyzing the Leakage Resistance of the NIST's Lightweight Crypto Competition's Finalists}
\author{Corentin Verhamme\inst{1} \and Ga\"{e}tan Cassiers\inst{1,2,3} \and Fran\c{c}ois-Xavier Standaert\inst{1}}
\institute{ICTEAM, Universit\'{e} catholique de Louvain, Louvain-la-Neuve, Belgium \and TU Graz, Graz, Austria \and Lamarr Security Research, Graz, Austria}
%----------------------------------------------------------------
\maketitle

\begin{abstract}
We investigate the security of the NIST Lightweight Crypto Competition's Finalists
against side-channel attacks. We start with a mode-level analysis that allows
us to put forward three candidates (Ascon, ISAP and Romulus-T) 
that stand out for their leakage properties
and do not require a uniform protection of all their computations thanks
to (expensive) implementation-level countermeasures.
We then implement these finalists and evaluate
their respective performances. Our results confirm the interest of so-called
leveled implementations (where only the key derivation and tag generation
require security against differential power analysis). They also
suggest that these algorithms differ more by their qualitative features 
(e.g., two-pass designs to improve confidentiality with decryption
leakage vs. one-pass designs, flexible overheads thanks to masking vs.
fully mode-level, easier to implement, schemes) than by their quantitative 
features, which all improve over the AES and are quite sensitive to
security margins against cryptanalysis.
\end{abstract}


\section{Introduction}
Security against side-channel attacks is explicitly mentioned by the NIST as a target in the
ongoing standardization process for lightweight cryptography.\footnote{\url{https://csrc.nist.gov/Projects/lightweight-cryptography}.} 
In this paper, we analyze the leakage resistance of 9 out of the 10 finalists of the 
competition. Our contributions in this respect are twofold.

\medskip

First, we use a framework introduced by Bellizia et al. to evaluate the
high-level leakage properties of the candidates' modes of 
operations~\cite{DBLP:conf/crypto/BelliziaBCGGMPP20}.
(We exclude Grain-128AEAD from our study, which 
cannot be captured with such a mode vs. primitive granularity.)
This high-level analysis allows us to observe that 6 candidates 
can mostly rely on (expensive) implementation-level countermeasures.
By contrast, 3 candidates (namely Ascon~\cite{DBLP:journals/joc/DobraunigEMS21}, ISAP~\cite{DBLP:journals/tosc/DobraunigEMMMPU20} and Romulus-T\footnote{\url{https://romulusae.github.io/romulus/}. Note that Romulus comes with different modes of operation. In particular, the (single-pass) N version does not 
provide mode-level leakage-resistance guarantees while the (two-pass) T version does.}) have leakage-resistant features
enabling so-called leveled implementations, where different parts of the implementations
require different (more or less expensive) implementation-level countermeasures.

\medskip

Second, we investigate the hardware performances of these 3 leakage-resistant
modes of operation and evaluate their leveled implementation.
In leveled implementations, we distinguish between Differential Power Analysis
(DPA), where the adversary is able to collect an adversarially chosen
number of measurements corresponding to fixed secret inputs to the target
primitive, and Simple Power Analysis (SPA), where the number of such
traces is small and bounded by design. The goal of mode-level protections
is to minimize the 
amount of computations that must be protected against DPA and SPA.
For Ascon and Romulus-T, we protect
the Key Derivation Function (KDF) and Tag Generation Function (TGF) 
against DPA with Hardware Private Circuits (HPC), 
a state-of-the-art masking scheme that jointly provides resistance against physical defaults and 
composability~\cite{DBLP:journals/tc/CassiersGLS21,DBLP:journals/tches/CassiersS21}. For ISAP, the
KDF and TGF are based on a leakage-resilient PRF that embeds a fresh re-keying mechanism
such that they only require
security against SPA~\cite{DBLP:conf/africacrypt/MedwedSGR10,DBLP:journals/jce/BelaidSHMMSST14}. The latter is natively (and efficiently) obtained
thanks to parallelism in hardware. 
For all 3 candidates, the bulk of the computation contains an internal re-keying mechanism. Hence,
guarantees of confidentiality with leakage essentially require its SPA security (again achieved with hardware parallelism). This part of the implementation can even leak in an unbounded manner if only integrity with leakage is required.

\smallskip

The hardware design space of Ascon (and ISAP, that relies on the same permutation) has already been
quite investigated in the literature, both regarding unprotected and 
masked implementations~\cite{DBLP:conf/dsd/GrossWDE15,Elsevier2017}. 
Our implementations heavily build on this state-of-the-art.
By contrast, to the best of our knowledge
such evaluations are a bit sparser for Romulus-T~\cite{NIST22}
and the Skinny block cipher it relies on~\cite{DBLP:journals/tosc/BeierleJKLMPSSS20},
especially for higher-order masked implementations.
Therefore, and as an additional technical contribution, we complete
the study of masked Skinny implementations tailored
for masking.

\medskip

We conclude that more than the quantitative comparison of the finalists,  
the main criteria that should help the NIST in selecting a lightweight 
cryptography standard (if leakage is deemed important) are qualitative. The limited relevance
of quantitative comparisons at this stage of the competition follows from
two facts. For ciphers that rely on comparable countermeasures for their DPA security (like
Ascon and Romulus-T, both leveraging masking), the performance gap is limited and quite sensitive
to security margins against cryptanalysis. Both are nevertheless significantly easier to protect against
leakage than the AES, as witnessed by simple proxies such as their number of AND gates or AND depth.
For ciphers that rely on different countermeasures for their DPA security (like ISAP, that leverages re-keying),
we currently lack (both theoretical and practical) tools that would allow 
a definitive comparison (e.g., with masking). By contrast, these three ciphers have different
qualitative features, leading to at least two questions that could (and we think, should) guide the final selection:
\begin{itemize}
\item \emph{Is confidentiality with decryption leakage wanted?} 
Ascon, ISAP and Romulus-T all reach the top of the hierarchy
in~\cite{DBLP:conf/latincrypt/GuoPPS19} for integrity with leakage (coined CIML2). The leveled
implementation of Ascon only provides confidentiality with encryption leakages and misuse-resilience
(coined CCAmL1): decryption queries of a ciphertext leak the underlying plaintext via a straightforward DPA.
The leveled implementations of ISAP and Romulus-T can additionally provide
confidentiality with decryption leakages and misuse-resilience (coined CCAmL2) at the cost
of being two-pass for decryption (they are only CCAmL1 if a single-pass
decryption is performed).

\item \emph{Flexibility or simplicity for the KDF and TGF?} Ascon and Romulus-T require
DPA countermeasures like masking to protect their KDF and TGF. Implementing masking
securely is a sensitive process that requires expertise~\cite{DBLP:conf/ctrsa/MangardPG05,DBLP:conf/cosade/CoronGPRRV12}. But it comes with a lot of flexibility: 
countermeasures do not always have to be deployed, different security vs. performance
trade-offs can be considered and one can have different security levels in encryption
and decryption. ISAP relies on a re-keying mechanism so that only SPA security is needed
for the whole implementation, which is easy to obtain in hardware.\footnote{~Security in low-end embedded software implementations
is unclear both for masking and re-keying, which can be the target of strong attacks
in low-noise contexts: see~\cite{DBLP:journals/tches/BronchainS21} for masking and~\cite{DBLP:journals/tches/KannwischerPP20,DBLP:conf/crypto/BelliziaBCGGMPP20} for re-keying. }
But it has no flexibility: the overheads of the leakage-resilient PRF have to be paid even if side-channel
security is not a concern. 
\end{itemize}
A slightly longer-term question relates to the choice between 
permutations and Tweakable Block Ciphers (TBCs). While the same leakage-resistant
features can be obtained at somewhat similar costs from  permutations and sponges, these
two building blocks also come with some differences. On the one hand,
TBC-based designs seem more amenable to security analyzes in the standard model~\cite{DBLP:journals/tches/BertiGPPS20,DBLP:conf/asiacrypt/BertiGPS21}, while
permutations currently require idealized 
assumptions~\cite{DBLP:conf/asiacrypt/DobraunigM19,DBLP:journals/tosc/GuoPPS20}.
On the other hand, TBC-based schemes enable performing an inverse-based tag verification
that can leak in full~\cite{DBLP:journals/tosc/BertiPPS17} while permutation-based schemes
require masking~\cite{DBLP:journals/tches/BronchainMPS21} or additional
computations~\cite{DBLP:conf/eurocrypt/DobraunigM21} for securing this part of their design
against leakage.


\section{Mode-level analysis}\label{sec:modes}

Our mode-level analysis follows the framework of Bellizia et al.~\cite{DBLP:conf/crypto/BelliziaBCGGMPP20}.
Because of place constraints, we do not detail the specifications of the NIST's
Lightweight Crypto Competition's Finalists and refer to the webpage
\url{https://csrc.nist.gov/Projects/lightweight-cryptography} for this purpose.
We rather focus on the features of these modes that are relevant 
for leakage.

\medskip

The high-level decomposition of the modes we will rely on is depicted in Figure~\ref{fig:decomposition}.
It includes a KDF that generates a fresh encryption key $K^*$, the bulk of the scheme
that processes the message blocks, the TGF that generates the authentication tag $T$
and the verification (that checks whether $T$ is correct). Some parts may naturally be empty for some
candidates.

\begin{figure}
	\vspace*{-0.0cm}
	\hspace*{0.0cm}\centering \includegraphics[width=12.0cm]{figures/mode_decomposition.pdf}
	\vspace*{0.3cm}
	\caption{Leakage-resistant modes of operation decomposition.}\label{fig:decomposition}\vspace*{-0.0cm}
\end{figure}

\medskip

The goal of this decomposition is to identify the parts of the modes
that must be implemented in a DPA-resistant manner and the parts of the modes that 
can be implemented with weaker guarantees. When analyzing confidentiality,
these weaker guarantees correspond to SPA security.
When analyzing integrity,
it is even possible to implement those parts without
any guarantee (which is referred to as the unbounded leakage model in
formal analyzes). We next classify the designs based on the amount of 
mode-level protections they embed.
At high-level (details are given in~\cite{DBLP:conf/crypto/BelliziaBCGGMPP20}),
Grade-0 designs do not provide mode-level leakage-resistance; Mode-1 designs
can be leveled to preserve confidentiality and integrity as long as only encryption
leakages are given to the adversary (i.e., CCAmL1 and CIML1); Mode-2 designs
can be leveled even if integrity with decryption leakage is required (i.e., CIML2); Mode-3 designs
complete the picture by allowing leveled implementations that preserve both confidentiality
and integrity with decryption leakages (i.e., CCAmL2 and CIML2).  

\subsubsection{Grade-0 designs (no mode-level protections).}
A first way to design modes of operation for lightweight cryptography 
is to focus exclusively on performance and to ignore leakage. This
is the case of modes where the long-term secret key is
used by most of the underlying primitives. In the NIST lightweight
crypto competition, it is for example what happens for
Elephant, GIFT-COFB, Romulus-N, Romulus-M and TinyJambu.
A protected implementation of Romulus-N targeting integrity with encryption leakage
is illustrated in Figure~\ref{fig:romulus_n},
where the blue color is used to reflect that the corresponding computations
must be protected against DPA. This requirement essentially holds for any security target (i.e., for confidentiality
and integrity, with or without nonce-misuse and leakage available in encryption or decryption).
We insist that being
Grade-0 does not imply that these modes cannot be protected against
leakage. It rather implies that this protection will be expensive
because uniformly applied to all the components of the modes.
The following (higher-level) designs gradually increase the mode-level protections,
leading to different trade-offs between the efficiency of their
unprotected implementations (that mildly decreases) and the efficiency
of their protected implementations (that significantly increases for long messages).


\begin{figure}
    \centering
    \input{./figures/mode_level_analysis/romulus_n_integrity.tex}
	\caption{Uniformly protected implementation of Romulus-N (integrity with encryption leakage).
	Blue blocks have to be secure against DPA.}
        \label{fig:romulus_n}\vspace*{-0.5cm}
\end{figure}

\subsubsection{Grade-1 designs (internal re-keying).} A first step towards
building modes of operation that cope better with leakage is to embed an internal
re-keying mechanism. In this case, the mode first generates a fresh
key $K^*$ from the long-term key and the nonce, which is then updated 
after the processing of each message block. As a result, and 
as long as the adversary can only observe encryption leakage 
without nonce misuse, only the KDF needs security against DPA (as there is
a DPA using the nonce) and all the other computations must only be protected 
against SPA. Such a leveled implementation is illustrated in Figure~\ref{fig:photon}
for PHOTON-Beetle. Unfortunately, this guarantee vanishes
as soon as nonce misuse or decryption leakage are granted to the adversary.
In this case the adversary can target the processing of one message block
with many different messages (while keeping the nonce and all the the other message blocks constant)
and perform a DPA to recover the corresponding intermediate state. In the
case of a P-sponge construction~\cite{Sponge07}, it is then possible to invert the permutation
and get back to the long-term key. 
In the NIST lightweight
crypto competition, it is the case of 
PHOTON-Beetle, Sparkle and Xoodyak.

\begin{figure}
    \centering
    \input{./figures/mode_level_analysis/photon_CIL1.tex}
	\caption{Leveled implementation of PHOTON-Beetle (integrity with encryption leakage).
	Blue (resp., green) blocks have to be secure against DPA (resp., SPA).}
        \label{fig:photon}\vspace*{-0.5cm}
\end{figure}

\subsubsection{Grade-2 (Grade-1 + strengthened KDF/TGF).}
The second step towards
building modes of operation that cope better with leakage is to strengthen the
KDF/TGF so that the recovery of an internal state of the mode cannot
lead to long-term secrets. This is easily (and efficiently) done
by making the KDF and the TGF non-invertible. In the case of 
sponges, it can be achieved by XORing the long-term key before and
after the permutation used to generate the fresh key $K^*$ and the
tag $T$. For TBCs, it is a direct consequence of their PRP 
security. In the NIST lightweight
crypto competition, it is for example the case of 
Ascon. For illustration, its leveled implementation 
is illustrated in
Figure~\ref{fig:Ascon}.

\begin{figure}[h]
    \begin{subfigure}{\textwidth} \centering
	\input{figures/mode_level_analysis/ascon_CIL1.tex}\caption{Integrity requirements (with decryption leakage).}
	\end{subfigure}
	\begin{subfigure}{\textwidth} \centering
	\input{figures/mode_level_analysis/ascon_CCAL1.tex}\caption{Confidentiality requirements (without decryption leakage).}
	\end{subfigure}
        \caption{Leveled implementation of Ascon.
            The blue blocks have to be protected against DPA and the green blocks
            have to be protected against SPA, while the white ones do not require
            protection against side-channel leakage.
        }
        \label{fig:Ascon}
\end{figure}

\medskip

The top of the figure depicts the integrity requirements. In this case, only
the KDF and the TGF (in blue) must be protected against DPA  and the rest of the computations (in white)
can leak in full. This guarantee holds even when nonce misuse and
leakage in decryption are granted to the adversary. It intuitively derives
from the fact that the ephemeral secrets cannot be used to infer long-term ones,
and corresponds to the top of the hierarchy introduced in~\cite{DBLP:conf/latincrypt/GuoPPS19}.
The bottom of the figure 
depicts the confidentiality requirements. In this case, it is naturally 
not possible to tolerate unbounded leakage. Yet, as long as the adversary 
is not granted with decryption leakage, only SPA security (in green) is required 
for this part of the computation. (The orange color for the plaintexts
is used to reflect that even their very manipulation may leak sensitive information).
The main attack vector that remains against this construction happens
with decryption leakage. Since the message is decrypted before
verifying the tag, an adversary can then 
target the processing of one message block with many different
messages (keeping the nonce and all the the other message blocks constant) and perform
a DPA to recover the corresponding intermediate state.
This reveals the ephemeral keystream, hence the message, but does not
affect the confidentiality of messages encrypted with a different nonce.

\subsubsection{Grade-3 (Grade-2 + two passes).}
The natural way to get rid of the last attack vector against Ascon
is to consider 2-pass designs (such as encrypt-then-MAC constructions).
In this case, the tag can be computed
from the ciphertext blocks and tested before the decryption takes place. 
 In the NIST lightweight
crypto competition, it is for example the case of 
ISAP (which is permutation-based) and Romulus-T (which is TBC-based). 
Their main difference lies in the way they secure their KDF and TGF.
Like Ascon,
Romulus-T (which is based on the TEDT mode of operation~\cite{DBLP:journals/tches/BertiGPPS20})
relies on masking for this purpose. By contrast, ISAP relies on 
a leakage-resilient PRF. As illustrated in Figure~\ref{fig:ISAP}, the leakage-resilient PRF
can be viewed as a re-keying scheme where the nonce bits are absorbed one 
by one so that each of its intermediate keys is only used to process two 
permutation calls. As a result, this PRF essentially ``reduces'' DPA security to SPA 
security, at the cost of iterating the Ascon-p$^1$ permutation.\footnote{Increasing the rate 
to absorb more bits and get a more efficient design is possible but it then opens
a DPA attack vector (so we do not consider this option here).}

\begin{figure}
    \centering
    \input{./figures/mode_level_analysis/isap_CCAmL2.tex}
	\caption{
            Leveled implementation of ISAP (confidentiality with decryption leakage).
            The green blocks have to be protected against SPA (with averaging), while the white
            ones do not require any protection against side-channel leakage.
        }\label{fig:ISAP}
\end{figure}

\begin{figure}
    \centering
    \input{figures/mode_level_analysis/rom-t-CCAmL2.tex}
    \caption{Leveled implementation of Romulus-T (confidentiality with decryption leakage).
            The blue blocks have to be protected against DPA and the green blocks
            have to be protected against SPA (with averaging), while the white ones do not require any
            protection against side-channel leakage.
    }
    \label{fig:TEDT}
\end{figure}

Overall, ISAP's confidentiality with decryption leakage requires two calls to the
leakage-resilient PRF and a plaintext processing that is secure against SPA.
We provide a similar picture for the leveled implementation
of Romulus-T in Figure~\ref{fig:TEDT}, where the KDF and TGF
are directly instantiated with a masked TBC. 
Note that the SPA-secure blocks of these two figures are in dark green to reflect the possibility
that the adversary repeats the same measurements to average the noise.
And as in the case of Ascon,
integrity with decryption leakage only requires the two protected calls (to 
the leakage-resilient PRF or masked TBC) and can let all the other computations leak in full.



\section{Hardware implementations}\label{sec:implem}

Given the previous analysis, it appears that Ascon, ISAP and Romulus-T are
the most promising candidates of the NIST lightweight crypto competition
for leakage-resistant implementations. In this section, we therefore investigate
their hardware implementations. For this purpose, we focus on
the security guarantees that they enable without a uniformly protected implementation.
We first investigate their primitives, with a special focus on Romulus-T
and its underlying TBC Skinny-384+ (for which, as mentioned in introduction,
the literature is a bit scarcer). We then detail the implementation of the
modes and report their performances (with ASIC synthesis). We use these results to confirm the
relevance of leveled implementations and to discuss the respective interest
of the three implemented ciphers in the context of the NIST competition.

\subsection{Masked implementation of the primitives}\label{subsec:prim}

We use the HPC2 masking scheme, as it allows almost arbitrary composition while
ensuring security against both hardware glitches and
transitions~\cite{DBLP:journals/tc/CassiersGLS21,DBLP:journals/tches/CassiersS21}.
The main characteristics of this masking scheme are the following.
The linear operations are very efficient, since they are made of purely
combinational logic and have a linear overhead in the masking order.
On the other hand, the non-linear operation, which is the 2-input AND gate (see
\autoref{algo:hpc2_mul}), has quadratic
overhead and asymmetric latency: 2~cycles with respect to one input, and only
1~cycle with respect to the other input.

\begin{algorithm}[tb]
    \caption{HPC2 AND gadget with $\nShares$ shares (sync. registers
    are omitted).}
    \label{algo:hpc2_mul}
    \begin{algorithmic}[1]
        \Require Sharings $\sharing{x}$, $\sharing{y}$
        \Ensure Sharing $\sharing{z}$ such that $z = x \cdot y$.
        \algrule
        \For{$i = 0 \text{ to }d-1$}
            \For{$j = i+1 \text{ to }d-1$}
                \State $r_{ij} \randtake \ft; \ r_{ji} \gets r_{ij}$
            \EndFor
        \EndFor
        \For{$i = 0 \text{ to }d-1$}
            \State $\share{z}{i} \gets \share{x}{i}\share{y}{i}$
            \For{$j = 0 \text{ to }d-1, j\neq i$}
                \State $\share{z}{i} \gets
                \share{z}{i} \oplus
                    \func{\reg}{\left(\share{x}{i}\oplus 1\right) r_{ij}}
                    \oplus \func{\reg}{\share{x}{i}\func{\reg}{\share{y}{j}\oplus r_{ij}}}
                    $
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}


\subsubsection{Skinny Sbox.}\label{subsub:skinny_sbox}
The Skinny Sbox (depicted in \autoref{fig:sboxclean}) is made of XOR gates (that are
linear, and therefore easy to implement) and of NOR gates that we implement
with a AND gate whose inputs are inverted.

We next propose two area-optimized architectures for this Sbox, that both
instantiate two masked AND and two masked XOR gates.
\begin{figure}
    \centering
    \input{figures/implem_prim/sbox_skinny.tex}
    \caption{Skinny Sbox circuit representation with NOR and XOR gates.}
    \label{fig:sboxclean}
\end{figure}
First, the high-throughput one is based on the observation that the Sbox can be
decomposed into 4~applications of a simpler function (as visible in
\autoref{fig:sboxclean}), followed by a wire shuffling.
This function has a latency of at least two cycles with our masking
scheme, due to the AND gate.
We therefore build the high-throughput Sbox by looping 4~times on a two-stage
pipeline.
The core of this pipeline is a simple function block B shown in
\autoref{fig:block}, which is then used twice and connected to combinational
logic to form the Sbox (\autoref{fig:sboxser_circuit}).
The two-stage pipeline can be used to perform simultaneously two Sbox
operations.
We finally add input and output synchronization registers such that the logic
performs two Sbox evaluations in 9~clock cycles, without the need for any
external synchronization mechanism.
\begin{figure}
	\begin{subfigure}[b]{.48\textwidth}
		\centering
		\input{./figures/implem_prim/block.tex}
		\caption{%
                    Inner logic block ``B'' for Sbox implementation, with one
                    AND and one XOR.
                }
                \label{fig:block}
	\end{subfigure}
        \hfill
	\begin{subfigure}[b]{.48\textwidth}
		\centering
		\input{./figures/implem_prim/sbox.tex}
		\caption{%
                    High-throughput Sbox architecture with input and output
                    sync. registers.
                }
                \label{fig:sboxser_circuit}
	\end{subfigure}
	\caption{%
            High-throughput masked Skinny Sbox.
        }
        \label{fig:sboxintro}
\end{figure}
Second, we design a low-latency architecture with an ALU-style design: the Sbox
inputs are stored in a register, as well as the outputs, and the data fed to
the two AND-XOR blocks are selected from these states (and from the input
wires) when needed (see \autoref{fig:sboxopt_circuit}).
This flexible architecture allows to benefit from the asymmetric latency of the
HPC2 AND gadgets, leading to a latency of 6~cycles for one Sbox evaluation (see
\autoref{fig:sbox_opt}).

\begin{figure}
    \begin{subfigure}[b]{.48\textwidth}
        \centering
        \input{./figures/implem_prim/sbox_skinny_colored.tex}
        \caption{%
            Decomposition of the logic circuit in iterated logic blocks (A to H).
        }
        \label{fig:sboxcolored}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{.48\textwidth}
        \centering
        \input{./figures/implem_prim/signal_sbox_skinny.tex}
        \caption{%
            Scheduling of the computations.
        }
        \label{fig:signal}
    \end{subfigure}
    \caption{%
        Decomposition and scheduling of the computations for low-latency masked
        Skinny Sbox: 8 logic blocks are scheduled on 2~block instances.
    }
    \label{fig:sbox_opt}
\end{figure}

\begin{figure}
    \centering
    \input{./figures/implem_prim/sbox_opt.tex}
    \caption{%
        Architecture of low-latency masked Skinny Sbox.
    }
    \label{fig:sboxopt_circuit}
    \label{fig:sbox}
\end{figure}

Lastly, we discuss fully pipeline architectures.
While such architectures can achieve very high throughput that compensate for
their large area, they are difficult to use in our case.
Indeed, we are not interested in parallel Skinny evaluations (since this is not
useful for encrypting a single message with a Romulus-T leveled
implementation). Therefore, the latency
overhead of filling the pipeline (of at least 6~cycles) is significant when it
is used for only 16 Sbox evaluations (a Skinny round).
We however note that the only other HPC Skinny implementation we
know of uses that strategy, and uses a depth-12 pipeline~\cite{khairallahhardware}.\footnote{%
    Which can be improved to depth-6 thanks to the asymmetric
    latency of HPC2 ANDs.
}

\subsubsection{Skinny.}\label{subsub:skinny}

Based on these Sbox architectures, we design three Skinny implementations with
various area vs. latency trade-offs.
The two first ones are simple round-based architectures, as shown in
\autoref{fig:skinny8}, where either 16~low-latency Sboxes (``low-latency
Skinny'', \skinnyll) or 8~high-throughput (``balanced Skinny'', \skinnyb)
Sboxes are used.
The third implementation (``small Skinny'', \skinnys) targets lower area: it is
a serialized architecture that instantiates only one high-throughput Sbox (that
is used 8~times per round), as shown in \autoref{fig:skinny1}.

\begin{figure}
    \centering
    \resizebox{.9\textwidth}{!}{\input{./figures/implem_prim/datapath_8B.tex}}
    \caption{Round-based masked Skinny architecture (\skinnyll and \skinnyb).}
    \label{fig:skinny8}
\end{figure}

\begin{figure}
    \centering
    \resizebox{.9\textwidth}{!}{\input{./figures/implem_prim/datapath_1B.tex}}
    \caption{Serialized masked Skinny architecture (\skinnys).}
    \label{fig:skinny1}
\end{figure}

Let us now discuss the performance of these implementations.
We consider latency, randomness requirements and area as performance metrics,
since the critical path
will be similar in all cases (it lies in the linear layer).
The latency and maximum randomness requirements per cycle
of the implementations are shown in \autoref{tab:latencyrandomness}.
%\footnote{%
%    This randomness figure characterizes the number of randomness generators
%    needed if no randomness is stored.
%}
We can see that the \skinnys implementation has 8~times the latency of \skinnyb (due to 8x
serialization), while \skinnyll reduces latency by 33~\% compared to \skinnyb.
Regarding randomness, the maximum randomness throughput of \skinnys is 8~times
lower than \skinnyb, and the one of \skinnyll is twice the one of \skinnyb.

\begin{table}
    \centering
    \setlength\tabcolsep{0.4em}
    \begin{tabular}{lcccccc}
        \toprule
       & \multirow{2}{*}{Latency [cycle]} & \multicolumn{5}{c}{Randomness [bit]} \\
       &                          & $d = 2$ & $d=3$   & $d = 4$ & $d=5$   & $d = 6$    \\
       \midrule
        \skinnys  & 2880                     & 2  & 6      & 12   & 20     & 30       \\
        \skinnyb  & 360                      & 16   & 48    & 96 & 160       & 240      \\
        \skinnyll & 240                      & 32       & 96   & 192    & 320  & 480    \\
    \bottomrule
    \end{tabular}
    \vspace*{3ex}
    \caption{
        Skinny-384+ masked implementations: total latency and maximum randomness
        consumption for a single clock cycle (where the total randomness consumption
        is $64 \cdot d \cdot (d-1)$ bits for all three implementations).
    }
    \label{tab:latencyrandomness}
\end{table}

Next, we look at area requirements in \autoref{fig:primarea}.
The Sbox logic area clearly reflects the architectural choices: 2 AND and XOR
gadgets for \skinnys, 16 of each for \skinnyb, and 32 of each for \skinnyll.
Next, the remaining Sbox area is fairly high for \skinnyll due to the large
number of Sbox instances and due to their large MUXes and registers.
For \skinnyb and \skinnys, the larger number MUXes and registers in the Sboxes
of the former compensate for the more complex datapath of the latter, resulting
in a similar ``routing'' area for both of them.
The remaining parts of Skinny are the same for all three architectures.
Overall, the difference in area between the architectures is small for low
number of shares, and increases as the latter grows.
For all considered number of shares ($d \le 6$), the Sboxes do not dominate the
area of neither \skinnys nor \skinnyb, hence \skinnys brings a limited area
gain at a large latency cost compared to \skinnyb.
On the other hand, \skinnyll has an area overhead of up to 39~\% (for $d\le 6$),
and a latency gain of 33~\% over \skinnyb.
\begin{figure}
	\centering
	\input{./figures/implem_prim/area.tex}
        \caption{
            Area requirements for the three masked Skinny hardware implementations in a
            \SI{65}{nm} ASIC technology using the HPC2 masking scheme.
        }
        \label{fig:primarea}\vspace*{-1cm}
\end{figure}

\subsection{Implementation of the modes}\label{subsec:modes}



We implemented side-channel protected hardware accelerators for
Romulus-N, Romulus-T, Ascon and ISAP, using the primitives described
in \autoref{tab:prim_latency}.
The Romulus-N implementation is fully masked and uses one
\skinnyll instance.
Next, the implementation of Romulus-T is leveled 
with one masked instance of Skinny (we also used \skinnyll) and four non-masked
Skinny instances (with a round-based architecture).
Similarly, the Ascon implementation is also leveled.
The masked \asconp primitive is based on the HPC2 masking scheme and is
serialized with 16 Sbox instances (each Sbox is a 2-stage pipeline 
performing 4~Sbox evaluations per round)\footnote{%
    This choice is somewhat arbitrary: we took a serialization factor that gives a good
    latency versus area trade-off.
    It also happens to lead to a latency of 6 clock cycles per round, which is
    the same latency as a round of \skinnyll.
},
while the non-masked permutation is round-based (1~cycle per round).
Finally, ISAP uses two instances of the non-masked \asconp primitive.

\begin{table}
    \centering
    \setlength\tabcolsep{0.4em}
    \begin{tabular}{lcccc}
        \toprule
    & \multicolumn{2}{c}{Masked}          & \multicolumn{2}{c}{Non-masked}          \\
    & Latency & Architecture & Latency & Architecture \\
    \midrule
        Skinny-384+  & 240 & \skinnyll          & 40  & round-based             \\
        $\asconp^{6}$  & &                & 6  & round-based              \\
        $\asconp^{12}$ & 72  & serialized 4x           & 12 & round-based              \\
        ISAP RK  &              &  & 152 & round-based \\ \bottomrule
    \end{tabular}
    \vspace*{3ex}
    \caption{
        Primitive implementations used in the AEAD cores: latency
        in clock cycles and architecture for masked and non-masked versions.
    }
    \label{tab:prim_latency}
\end{table}

Let us first discuss the latency of these implementations with
\autoref{fig:modelatency}.
The encryption time of Romulus-N grows very quickly with the message size due
to the need of masking all Skinny calls, which are slow compared to non-masked
calls (as shown in \autoref{tab:prim_latency}).
However, for very short messages, Romulus-N is fairly competitive thanks to its
low number of Skinny calls it that case.
On the other hand, Romulus-T has a larger upfront cost, due to the larger
number of Skinny calls even for short messages, however the mode-level leakage resistance
allows to use non-masked calls for the bulk processing, resulting in
lower latency than Romulus-N for long messages.
Next, Ascon enjoys lower initial latency and long-message latency than Romulus-T.
This is due to the lower number of rounds in $\asconp^{6}$ and $\asconp^{12}$ compared to
Skinny (which has 40 rounds).
Finally, the latency of ISAP is between the one of Ascon and Romulus-T.
Indeed, ISAP's bulk processing is very similar to Ascon's, but uses more rounds
to increase the security margin in presence of leakage.
Moreover, the leakage-resilient PRF of ISAP uses many permutation rounds, which
makes it slower than a masked Ascon for short messages, while still being
faster than Romulus-T.

\begin{figure}
    \centering
    \input{./figures/implem_mode/latency_rel.tex}
    \caption{Encryption latency as a function of the message size.}
    \label{fig:modelatency}
\end{figure}

\begin{figure}
    \centering
    \input{./figures/implem_mode/area.tex}
    \caption{%
        Area requirements of leakage-resistant hardware AEAD cores in
        \SI{65}{nm} ASIC technology.
        For leveled implementations, the area is split in three part:
        DPA-protected (i.e., masked) primitives, SPA-protected primitives (implemented in parallel), and mode (i.e., logic not in a primitive).
				RN/RT respectively stand for Romulus-N/Romulus-T and A stands for Ascon.
    }
    \label{fig:modearea}
\end{figure}


Let us now discuss the area usage with \autoref{fig:modearea}.
As a general trend, for implementations with a masked primitive, the area for
that primitive dominates the overall area, with the exception of Romulus-T with
$d=2$ shares (where the area of the four non-masked Skinny instances dominates).
These results therefore confirms the interest of leveled implementations.
Next, the areas for all these modes is fairly similar, with a slight advantage
to Ascon and Romulus-N at $d=2,3$ shares thanks to their lower unmasked area, while
Romulus-T and Romulus-N are a bit better than Ascon for larger numbers of
shares, thanks to using less masked AND gadgets.
Lastly, the area for ISAP is similar to the area of the leveled implementations
with $d=2$ shares.

\section{Conclusion}

Even though the previous quantitative results should be interpreted with care, since
they explore only a few points in the design space (e.g., we considered only
round-based architectures for non-masked primitives and did not optimize the
masking randomness usage), their comparison highlights a few general trends.

\smallskip

First, for long messages, leveled implementations bring large latency
improvements while their area overheads remain small over non-leveled
implementations. This is because unmasked primitives are small compared to the masked
ones, especially when the number of shares is large.
This smaller unmasked area as well as lower latency naturally translate
into large energy savings.
The candidates that can be implemented in such a way for both
encryption and decryption (grade-2 and grade-3, see
\autoref{tab:modes_grades}) will benefit most from these savings.
However, having such mode-level characteristics usually implies more complex
modes of operations, which leads to worse performance for small messages, as
shown by the comparison between Romulus-N and the grade-2/grade-3 candidates.

\begin{table}
    \centering
    \setlength\tabcolsep{0.0em}
    \begin{tabular}{c@{\hspace{1.0em}}c@{\hspace{1.0em}}c}
        \toprule
        Grade & Security & Candidates \\
        \midrule
        0 & CCA+CI & Elephant, GIFT-COFB, Romulus-M/N, TinyJambu \\
        1 & CCAL1+CIL1 & PHOTON-Beetle, Sparkle, Xoodyak \\
        2 & CCAmL1+CIML2 & Ascon \\
        3 & CCAmL2+CIML2 & ISAP, Romulus-T \\
        \bottomrule
    \end{tabular}
    \vspace*{3ex}
    \caption{
        NIST LWC finalists grouped by mode-level leakage resistance.
    }
    \label{tab:modes_grades}\vspace*{-0.5cm}
\end{table}

Second, the leakage-resilient PRF technique used by ISAP leads to low area
implementation (similar to a leveled implementations with two shares), and
its latency is comparable to leveled implementations.
Such techniques therefore appear quite promising in hardware implementation
setting. Yet, we note that on the side-channel security side, the formal security 
guarantees of such implementations have been much less analyzed than masking
and their practical security evaluation can be more challenging as well (see, e.g.,~\cite{DBLP:conf/cosade/UdvarhelyiBS21}).


Finally, we observe that the different security margins of the algorithms we implemented
can explain some of the observed performance differences.
For example, the differences in latency between the leveled implementations of
Ascon and ISAP are explained by their number of rounds: the hashing part of ISAP
uses $\asconp^{12}$ while the Ascon inner sponge part uses only $\asconp^{6}$.
When considering CIML2, both should however withstand the same attacks.

Overall, these results backup our suggestion that
from a side-channel security viewpoint, 
the finalists of the NIST's Lightweight Crypto competition differ more 
by their qualitative features than by their quantitative performances.

%Finally qualitative properties are not free (CCAmL2, permutation vs TBC,
%flexibility w.r.t. SCA protection), so that's more the question than pure best
%performance.
%
%
%future work SW

\medskip

\noindent\textbf{Acknowledgments.} Ga\"{e}tan Cassiers and Fran\c{c}ois-Xavier Standaert are respectively
Research Fellow and Senior Associate Researcher of the Belgian Fund for Scientific
Research (FNRS-F.R.S.). This work has been funded in part by the ERC consolidator grant 
number 724725 (acronym SWORD), by the Walloon region CyberExcellence project number 2110186 (acronym Cyberwal) and by the Horizon Europe project 1010706275 (acronym REWIRE).


\bibliographystyle{alpha}
\bibliography{refs}

\end{document}
